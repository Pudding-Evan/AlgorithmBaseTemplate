# 快速排序



## 题目

>给定你一个长度为 n 的整数数列。
>
>请你使用快速排序对这个数列按照从小到大进行排序。
>
>并将排好序的数列按顺序输出。
>
>输入格式
>输入共两行，第一行包含整数 n。
>
>第二行包含 n 个整数（所有整数均在 1∼109 范围内），表示整个数列。
>
>输出格式
>输出共一行，包含 n 个整数，表示排好序的数列。
>
>数据范围
>1≤n≤100000
>输入样例：
>5
>3 1 2 4 5
>输出样例：
>1 2 3 4 5

## 思路 | 模板

快排是基于分治的思想

1. 确定分界点 
2. 调整区间：第一个区间内所有数小于等于x，所有大于x的数在右边
3. 递归处理左右两端



* 有一个 优雅的计算方式
  * 左右指针横扫，当左边下标i扫到大于x数停下，右边j扫描直到右边扫到小于x的值，交换左右两边i,j的数字。
  * 继续上述流程，直到左右两边相遇

## 代码

```c++
#include <iostream>
using namespace std;

const int N = 1e6 + 10;
int n;
int q[N];

void quick_sort(int q[],int l,int r)
{
	if(l >= r ) return;
	int x = q[(l+r) >> 1],i = l-1,j = r + 1; // 朝两边扩一格，因为每次都是直接朝中间扫一格 x 可以是任何值 最好是中间值
	while(i < j)
	{	
    	do i++; while(q[i] < x);
    	do j--; while(q[j] > x);
    	if(i < j) swap(q[i],q[j]);
	}
	
	quick_sort(q,l,j);
	quick_sort(q,j+1,r);
    
    // 边界问题: 如果是用i的话，不能取到左边界,同理，用j的话，x不能取到右边界，否则死循环
    // int x = q[l] ——> 有可能会死循环
    // quick_sort(q,l,i-1);
   //  quick_sort(q,i,r);
    
}


int main()
{
	scanf("%d",&n);
	for(int i =0;i<n;i++)	scanf("%d",&q[i]);
	
	quick_sort(q,0,n-1);
	
	for(int i = 0;i< n ;i++) printf("%d ",q[i]);
	return 0;

}

```

